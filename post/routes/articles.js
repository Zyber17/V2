// Generated by CoffeeScript 1.6.3
(function() {
  var db, findArticle, moment, photo_bucket_name, photo_bucket_url, string;

  db = require('../db');

  moment = require('moment');

  string = require('string');

  photo_bucket_name = process.env.NODE_ENV === 'dev' ? 'torch_test' : 'torch_photos';

  photo_bucket_url = "http://s3.amazonaws.com/" + photo_bucket_name + "/";

  exports.index = function(req, res, next) {
    return db.Articles.find({
      publishDate: {
        $lte: moment().toDate()
      },
      status: 4
    }, {
      publishDate: 1,
      truncated: 1,
      title: 1,
      author: 1,
      slug: 1,
      photos: 1,
      views: 1
    }).sort({
      'publishDate': -1,
      'lastEditDate': -1
    }).limit(6).execFind(function(err, recent) {
      var article, i, rotator, top_recent, trending, _i, _j, _len, _len1;
      if (!err) {
        if (recent.length) {
          rotator = [];
          for (i = _i = 0, _len = recent.length; _i < _len; i = ++_i) {
            article = recent[i];
            if ((article.photos != null) && (article.photos[0] != null)) {
              rotator.push({
                body: article.truncated,
                title: string(article.title).truncate(75).s,
                slug: "/articles/" + article.slug + "/",
                rotator: photo_bucket_url + article._id + '/' + article.photos[article.photos.length - 1].name
              });
            }
          }
          rotator = rotator.slice(0, 3);
          top_recent = recent.sort(function(a, b) {
            return b.views - a.views;
          });
          trending = [];
          for (i = _j = 0, _len1 = top_recent.length; _j < _len1; i = ++_j) {
            article = top_recent[i];
            trending.push({
              body: article.truncated,
              author: article.author,
              title: string(article.title).truncate(75).s,
              date: {
                human: moment(article.publishDate).format("MMM D, YYYY"),
                robot: moment(article.publishDate).toISOString().split('T')[0]
              },
              slug: "/articles/" + article.slug + "/",
              section: JSON.stringify(article.section),
              photo: article.photos[0] ? photo_bucket_url + article._id + '/' + (article.photos.length > 1 ? article.photos[article.photos.length - 2].name : article.photos[0].name) : void 0,
              isPublished: 2
            });
          }
          console.log(JSON.stringify(trending));
          return res.render('index', {
            rotator: rotator,
            trending: trending
          });
        } else {
          return res.render('errors/404', {
            _err: ["No articles found"]
          });
        }
      } else {
        console.log("Error (articles): " + err);
        return res.end(JSON.stringify(err));
      }
    });
  };

  exports.json = function(req, res, next) {
    exports.index = function(req, res, next) {};
    return db.Articles.find({
      publishDate: {
        $lte: moment().toDate()
      },
      status: 4
    }, {
      publishDate: 1,
      body: 1,
      title: 1,
      author: 1,
      slug: 1,
      photos: 1,
      _id: 0
    }).sort({
      'publishDate': -1,
      'lastEditDate': -1
    }).limit(10).execFind(function(err, recent) {
      var article, i, _i, _len;
      if (!err) {
        if (recent.length) {
          for (i = _i = 0, _len = recent.length; _i < _len; i = ++_i) {
            article = recent[i];
            recent[i].body.slice(0);
          }
          return res.json(recent);
        } else {
          return res.render('errors/404', {
            _err: ["No articles found"]
          });
        }
      } else {
        console.log("Error (articles): " + err);
        return res.end(JSON.stringify(err));
      }
    });
  };

  exports.view = function(req, res, next) {
    var update;
    update = true;
    if (req.session.isUser === true) {
      update = false;
    }
    return findArticle(req.params.slug, update, function(err, resp) {
      var comment, comments, galleryUrls, i, isGallery, now, options, photo, revbody, revision, versions, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      res.end('hi');
      if (!err) {
        if (resp) {
          versions = [];
          now = moment();
          revbody = resp.body.slice();
          _ref = revbody.reverse();
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            revision = _ref[i];
            versions[i] = {
              ago: moment.duration(moment(revision.editDate).diff(now, 'milliseconds'), 'milliseconds').humanize(true),
              editor: revision.editor,
              num: i + 1
            };
          }
          comments = [];
          _ref1 = resp.staffComments;
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            comment = _ref1[i];
            comments[i] = {
              ago: moment.duration(moment(comment.createdDate).diff(now, 'milliseconds'), 'milliseconds').humanize(true),
              exactDate: moment(revision.createdDate).toISOString(),
              author: comment.author,
              body: comment.body,
              edited: comment.edited
            };
          }
          isGallery = resp.isGallery && resp.photos[0] ? true : false;
          if (isGallery) {
            galleryUrls = [];
            _ref2 = resp.photos;
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              photo = _ref2[_k];
              galleryUrls.push(photo_bucket_url + resp._id + '/' + photo.name);
            }
          }
          options = {
            body: resp.body[0].body,
            versions: versions.reverse(),
            resp: resp,
            date: {
              human: resp.publishDate ? moment(resp.publishDate).format("MMM D, YYYY") : void 0,
              robot: resp.publishDate ? moment(resp.publishDate).toISOString().split('T')[0] : void 0
            },
            msg: null,
            title: resp.title,
            staff: req.session.isStaff || false,
            comments: comments,
            photo: resp.photos[0] ? photo_bucket_url + resp._id + '/' + (resp.photos.length > 1 ? resp.photos[resp.photos.length - 2].name : resp.photos[0].name) : void 0,
            section: resp.section,
            isGallery: isGallery ? resp.isGallery : false,
            galleryItems: isGallery ? galleryUrls : null,
            isVideo: resp.isVideo ? resp.isVideo : false,
            videoEmebed: resp.videoEmebed ? resp.videoEmebed : null
          };
          if (resp.publishDate) {
            options.resp.date = moment(resp.publishDate).format("MMMM D, YYYY");
          } else {
            options.resp.date = null;
          }
          if (resp.publishDate && moment(resp.publishDate) < moment()) {
            return res.render('article', options);
          } else {
            if (req.session.isUser) {
              options.msg = "This article is not yet released, you’re seeing it because you’" + (req.session.user.isStaff ? "re on staff" : "ve been granted early access") + ".";
              return res.render('article', options);
            } else {
              return res.render('errors/404', {
                err: "No article found"
              });
            }
          }
        } else {
          return res.render('errors/404', {
            err: "No article found"
          });
        }
      } else {
        console.log("Error (articles): " + err);
        return res.end(JSON.stringify(err));
      }
    });
  };

  findArticle = function(slug, update, callback) {
    if (update == null) {
      update = false;
    }
    return db.Articles.findOne({
      slug: slug
    }).select({
      publishDate: 1,
      body: 1,
      truncated: 1,
      title: 1,
      author: 1,
      bodyType: 1,
      lockHTML: 1,
      status: 1,
      publication: 1,
      approvedBy: 1,
      staffComments: 1,
      views: 1,
      slug: 1,
      photos: 1,
      section: 1,
      isGallery: 1,
      isVideo: 1,
      videoEmebed: 1
    }).exec(function(err, resp) {
      if (update) {
        resp.views++;
        return resp.save(callback(err, resp));
      } else {
        return callback(err, resp);
      }
    });
  };

}).call(this);
